import {
  init,
  require_eventemitter3,
  require_lodash,
  require_lodash2
} from "./chunk-2OLX5SES.js";
import {
  require_joi_browser_min
} from "./chunk-N6OLAKDP.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import "./chunk-AEPXQN22.js";
import "./chunk-4NQ5PR4L.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React2 = require_react();
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState3 = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React2.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState3({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React2.useSyncExternalStore !== void 0 ? React2.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/@web3-onboard/react/dist/context.js
var React = __toESM(require_react(), 1);

// node_modules/@web3-onboard/core/dist/index.js
var import_joi = __toESM(require_joi_browser_min());
var import_lodash = __toESM(require_lodash());
var import_lodash2 = __toESM(require_lodash2());
var import_eventemitter3 = __toESM(require_eventemitter3());

// node_modules/@web3-onboard/react/dist/context.js
var HOOK_ERROR_MESSAGE = "Must call the provided initialization method`init` method before using hooks.";
var web3OnboardGlobal = void 0;
var usingContextProvider = false;
var init2 = (options) => {
  web3OnboardGlobal = init(options);
  return web3OnboardGlobal;
};
var Context = React.createContext(void 0);
function Web3OnboardProvider({ children, web3Onboard }) {
  usingContextProvider = true;
  web3OnboardGlobal = void 0;
  return React.createElement(Context.Provider, { value: web3Onboard }, children);
}
function useWeb3Onboard() {
  const web3Onboard = usingContextProvider ? React.useContext(Context) : web3OnboardGlobal;
  if (!web3Onboard) {
    throw new Error(HOOK_ERROR_MESSAGE);
  }
  return web3Onboard;
}

// node_modules/@web3-onboard/react/dist/hooks/useAccountCenter.js
var useAccountCenter = () => useWeb3Onboard().state.actions.updateAccountCenter;

// node_modules/@web3-onboard/react/dist/hooks/useAppState.js
var import_react = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
var useAppState = (stateKey = void 0) => {
  const web3Onboard = useWeb3Onboard();
  const { select, get } = web3Onboard.state;
  const subscribe = (0, import_react.useCallback)((onStoreChange) => {
    const { unsubscribe } = stateKey ? select(stateKey).subscribe(onStoreChange) : select().subscribe(onStoreChange);
    return () => unsubscribe;
  }, [stateKey]);
  const getSnapshot = (0, import_react.useCallback)(() => {
    const snapshot = get();
    return stateKey ? snapshot[stateKey] : snapshot;
  }, [stateKey]);
  const getServerSnapshot = () => getSnapshot();
  return (0, import_shim.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);
};

// node_modules/@web3-onboard/react/dist/hooks/useConnectWallet.js
var import_react2 = __toESM(require_react(), 1);
var useConnectWallet = () => {
  const web3Onboard = useWeb3Onboard();
  const { connectWallet, disconnectWallet } = web3Onboard;
  const wallets = useAppState("wallets");
  const wallet = wallets[0] || null;
  const [connecting, setConnecting] = (0, import_react2.useState)(false);
  const connect = (0, import_react2.useCallback)(async (options) => {
    setConnecting(true);
    const walletState = await connectWallet(options);
    setConnecting(false);
    return walletState;
  }, []);
  const disconnect = (0, import_react2.useCallback)(async ({ label }) => {
    setConnecting(true);
    const walletState = await disconnectWallet({ label });
    setConnecting(false);
    return walletState;
  }, []);
  const updateBalances = web3Onboard.state.actions.updateBalances;
  const setWalletModules = web3Onboard.state.actions.setWalletModules;
  const setPrimaryWallet = web3Onboard.state.actions.setPrimaryWallet;
  return [
    { wallet, connecting },
    connect,
    disconnect,
    updateBalances,
    setWalletModules,
    setPrimaryWallet
  ];
};

// node_modules/@web3-onboard/react/dist/hooks/useNotifications.js
var useNotifications = () => {
  const web3Onboard = useWeb3Onboard();
  const customNotification = web3Onboard.state.actions.customNotification;
  const updateNotify = web3Onboard.state.actions.updateNotify;
  const preflightNotifications = web3Onboard.state.actions.preflightNotifications;
  return [
    useAppState("notifications"),
    customNotification,
    updateNotify,
    preflightNotifications
  ];
};

// node_modules/@web3-onboard/react/dist/hooks/useSetChain.js
var import_react3 = __toESM(require_react(), 1);
var useSetChain = (walletLabel) => {
  const web3Onboard = useWeb3Onboard();
  const { setChain } = web3Onboard;
  const { wallets, chains } = useAppState();
  const getChain = () => {
    const wallet = walletLabel ? wallets.find(({ label }) => label === walletLabel) : wallets[0];
    return wallet && wallet.chains ? wallet.chains[0] : null;
  };
  const connectedChain = getChain();
  const [settingChain, setInProgress] = (0, import_react3.useState)(false);
  const set = (0, import_react3.useCallback)(async (options) => {
    setInProgress(true);
    const success = await setChain({ ...options, wallet: walletLabel });
    setInProgress(false);
    return success;
  }, []);
  return [{ chains, connectedChain, settingChain }, set];
};

// node_modules/@web3-onboard/react/dist/hooks/useSetLocale.js
var useSetLocale = () => useWeb3Onboard().state.actions.setLocale;

// node_modules/@web3-onboard/react/dist/hooks/useWallets.js
var useWallets = () => useAppState("wallets");

// node_modules/@web3-onboard/react/dist/hooks/useUpdateTheme.js
var useUpdateTheme = () => useWeb3Onboard().state.actions.updateTheme;
export {
  Web3OnboardProvider,
  init2 as init,
  useAccountCenter,
  useAppState,
  useConnectWallet,
  useNotifications,
  useSetChain,
  useSetLocale,
  useUpdateTheme,
  useWallets
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@web3-onboard_react.js.map
